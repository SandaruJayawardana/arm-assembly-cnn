//
asm("
push {r4,r5,r6,r7,r8,r9,r10};
//vpush {s0-s6}; //reserved for subrouting (s0-s15)
//vpush {s8-s13};//reserved for subrouting(s0-s15)
vpush {s16-s18};
vpush {s21-s23};
vpush {s24-s29};

mov r7,#0;
vmov s6,r7;//to compare with 0 for leaky activation
mov r7,#0b00111101110011001100110011001101; //0.1 in floating point leaky activation
vmov s7,r7;

mov r5,#2;//set the len = 3 (size of the vectors)
mov r5,r5,LSL #16;
vmrs r4,fpscr;
orr r4,r4,r5;
vmsr fpscr,r4;//set len end


// r0<-ArrayStart, r1<- X*4, r2<-Y*4, r3<-kernalStart, r4<- i, r5<-j, r6<-currentAddr,r8<- currentKernal,r9<-save location, r7<-[r1]
mov r6,r0;
mov r9,r0;
mov r4,#2;//start from 2
mov r5,#2;//start from 2
//store kernal {s21-s29}
mov r7,r3;
vldmia r7!,{s21-s23};
vldmia r7!,{s24-s26};
vldmia r7!,{s27-s29};
ldr r7,[r1];//r7=width of image*4


mov r8,r6;//store starting addr r6=current position

//load image 3 pix
vldmia r8,{s16-s18};
vmul.f32 s8,s16,s21;

//load image 2nd row 3 pix
add r8,r8,r7;//adjest the array pointer (increment by width)
vldmia r8,{s16-s18};
vmul.f32 s11,s16,s24;
vadd.f32 s8,s8,s11;

//load image 3rd row 3 pix
add r8,r8,r7;//adjest the array pointer (increment by width)
vldmia r8,{s16-s18};
vmul.f32 s11,s16,s27;
vadd.f32 s8,s8,s11;
//mov 3 row summations
vmov s0,s8;
vmov s4,s9;
vmov s5,s10;
//add 3 rows
vadd.f32 s4,s4,s5;
vadd.f32 s0,s0,s4;//convoluted first value
//add r7,r7,#1;

//start second conv

//image start addr pointer
add r8,r6,#4;
//load image 3 pix
vldmia r8,{s16-s18};
vmul.f32 s8,s16,s21;

//load image 2nd row 3 pix
add r8,r8,r7;//adjest the array pointer (increment by width)
vldmia r8,{s16-s18};
vmul.f32 s11,s16,s24;
vadd.f32 s8,s8,s11;

//load image 3rd row 3 pix
add r8,r8,r7;//adjest the array pointer (increment by width)
vldmia r8,{s16-s18};
vmul.f32 s11,s16,s27;
vadd.f32 s8,s8,s11;
//mov 3 row summations
vmov s1,s8;
vmov s4,s9;
vmov s5,s10;
//add 3 rows
vadd.f32 s4,s4,s5;
vadd.f32 s1,s1,s4;//convoluted second value
//add r7,r7,#1;

//start third conv

//image start addr pointer
add r8,r6,r7;
//load image 3 pix
vldmia r8,{s16-s18};
vmul.f32 s8,s16,s21;

//load image 2nd row 3 pix
add r8,r8,r7;//adjest the array pointer (increment by width)
vldmia r8,{s16-s18};
vmul.f32 s11,s16,s24;
vadd.f32 s8,s8,s11;

//load image 3rd row 3 pix
add r8,r8,r7;//adjest the array pointer (increment by width)
vldmia r8,{s16-s18};
vmul.f32 s11,s16,s27;
vadd.f32 s8,s8,s11;
//mov 3 row summations
vmov s2,s8;
vmov s4,s9;
vmov s5,s10;
//add 3 rows
vadd.f32 s4,s4,s5;
vadd.f32 s2,s2,s4;//convoluted second value
//add r7,r7,#1;

//start forth conv

//image start addr pointer
add r8,r6,r7;
add r8,r8,#4;
//load image 3 pix
vldmia r8,{s16-s18};
vmul.f32 s8,s16,s21;

//load image 2nd row 3 pix
add r8,r8,r7;//adjest the array pointer (increment by width)
vldmia r8,{s16-s18};
vmul.f32 s11,s16,s24;
vadd.f32 s8,s8,s11;

//load image 3rd row 3 pix
add r8,r8,r7;//adjest the array pointer (increment by width)
vldmia r8,{s16-s18};
vmul.f32 s11,s16,s27;
vadd.f32 s8,s8,s11;
//mov 3 row summations
vmov s3,s8;
vmov s4,s9;
vmov s5,s10;
//add 3 rows
vadd.f32 s4,s4,s5;
vadd.f32 s3,s3,s4;//convoluted second value
//add r7,r7,#1;

//leaky activation  (out = (x>0)? x:0.1x) //s6=0 //s7=0.1
vcmp.f32 s0,s6;
//bg branch greater than
vmul.f32 s0,s0,s7;

vcmp.f32 s1,s6;
//bg branch greater than
vmul.f32 s0,s0,s7;

vcmp.f32 s2,s6;
//bg branch greater than
vmul.f32 s0,s0,s7;

vcmp.f32 s3,s6;
//bg branch greater than
vmul.f32 s0,s0,s7;

//Max pooling 
vcmp.f32 s0,s1;

vcmp.f32 s2,s3;

vcmp.f32 s0,s2;

vcmp.f32 s0,s3;

vcmp.f32 s1,s2;

vcmp.f32 s1,s3;

vstr s0,[r9];
vstr s1,[r9];
vstr s2,[r9];
vstr s3,[r9];
add r9,r9,#4; // increment save location
add r4,r4,#2;

//adjest registers to looping
add r6,r6,#8;// increment current position by 2 numbers
cmp r4,r7; // r4-r1
//greater than or equal
	mov r4,#2;//reset colomn
	add r5,r5,#2;//increment row
	cmp r5,r2; // compare end of the row
	//greater than
		//finished

//greater than 
	sub r6,r6,#4;//sub 1 from current position 
//else
	//r6 is properly incremented

mov r5,#2;// set the len = 0
mvn r5,r5,LSL #16;
fmrx r4,fpscr;
and r4,r4,r5;
fmxr fpscr,r4;// set len end

pop {r4,r5,r6,r7,r8,r9,r10};
//vpop {s0-s6};//reserved for subrouting (s0-s15)
//vpop {s8-s13};//reserved for subrouting (s0-s15)
vpop {s16-s18};
vpop {s21-s23};
vpop {s24-s29};